{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "algo-notes", "pdf_name": "ALGORTIHM-SHORT-NOTES-_compressed.pdf", "pages": 21, "question_id": "algo_q1", "question": "What is the main objective of algorithm analysis?", "expected": "- Compare algorithms based on efficiency\n- Measure time and space requirements\n- Select the most optimal solution", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "The main objective of algorithm analysis is to evaluate and compare the efficiency and performance of algorithms in terms of time complexity and space complexity.", "citations": "", "retrieved_chunks": "", "latency_s": 5.4066}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "algo-notes", "pdf_name": "ALGORTIHM-SHORT-NOTES-_compressed.pdf", "pages": 21, "question_id": "algo_q1", "question": "What is the main objective of algorithm analysis?", "expected": "- Compare algorithms based on efficiency\n- Measure time and space requirements\n- Select the most optimal solution", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "The main objective of algorithm analysis, according to the context provided, is to compare algorithms mainly in terms of running time but also in terms of other factors like memory and developer effort. This is aimed at determining resource consumption and finding out efficient solutions.", "citations": "p2:c0|p11:c0|p11:c2|p12:c2|p12:c0", "retrieved_chunks": "p2: Module 1: Analysis of Algorithm  Aim : T he goal of analysis of algorithms is to  compare algorithms mainly in terms of running time  but also in terms of other factors like memory,  developer effort.  Need for Analysis (Why to analyze || What to  analyze || How to analyze)  1. To determine resource consumption <resource such that space+time+cost+register> Resources may differ from domain to domain. 2. Performance comparison to find out efficient solution Methodology of algorithm  ● Depends on language ● Operating system ● Hardware (CPU, processor, memory, Input/output) Types of analysis  1. Aposteriori analysis(platform dependent) : It gives exact value in real units. 2. Apriori analysis(platform independent)  : It allows us to calculate the relative efficient performance of two algor", "latency_s": 65.2741}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "algo-notes", "pdf_name": "ALGORTIHM-SHORT-NOTES-_compressed.pdf", "pages": 21, "question_id": "algo_q2", "question": "Differentiate between a priori and a posteriori analysis.", "expected": "- A priori is platform independent\n- A posteriori depends on hardware and software\n- A priori uses mathematical analysis\n- A posteriori uses actual program execution", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "A priori knowledge is derived logically from ideas independent of experience, while a posteriori knowledge comes from experience or empirical evidence.", "citations": "", "retrieved_chunks": "", "latency_s": 5.3293}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "algo-notes", "pdf_name": "ALGORTIHM-SHORT-NOTES-_compressed.pdf", "pages": 21, "question_id": "algo_q2", "question": "Differentiate between a priori and a posteriori analysis.", "expected": "- A priori is platform independent\n- A posteriori depends on hardware and software\n- A priori uses mathematical analysis\n- A posteriori uses actual program execution", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "A priori analysis and a posteriori analysis differ primarily in their approach to determining resource consumption and performance:\n\n- **A posteriori Analysis**: This type of analysis is platform-dependent, meaning it gives exact values for resources such as time, space, cost, etc., but these values can vary based on the specific hardware, operating system, programming language, and other factors. It provides real-time or actual measurements.\n\n- **A priori Analysis**: In contrast, this method is platform-independent; it allows us to calculate the relative efficient performance of two algorithms without needing to know the exact details of the execution environment. While it won't provide real values in units like a posteriori analysis does, it helps in comparing and determining which algorithm might perform better under different conditions by focusing on the asymptotic behavior rather than specific hardware or software configurations.", "citations": "p2:c0|p5:c0|p2:c1|p4:c0|p11:c2", "retrieved_chunks": "p2: Module 1: Analysis of Algorithm  Aim : T he goal of analysis of algorithms is to  compare algorithms mainly in terms of running time  but also in terms of other factors like memory,  developer effort.  Need for Analysis (Why to analyze || What to  analyze || How to analyze)  1. To determine resource consumption <resource such that space+time+cost+register> Resources may differ from domain to domain. 2. Performance comparison to find out efficient solution Methodology of algorithm  ● Depends on language ● Operating system ● Hardware (CPU, processor, memory, Input/output) Types of analysis  1. Aposteriori analysis(platform dependent) : It gives exact value in real units. 2. Apriori analysis(platform independent)  : It allows us to calculate the relative efficient performance of two algor", "latency_s": 114.2852}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "algo-notes", "pdf_name": "ALGORTIHM-SHORT-NOTES-_compressed.pdf", "pages": 21, "question_id": "algo_q3", "question": "Define Big-O notation with an example.", "expected": "- Represents asymptotic upper bound\n- Describes worst-case complexity\n- Ignores constants and lower-order terms", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Big-O notation is used in computer science to describe the performance or complexity of an algorithm. Specifically, it defines the upper bound of the growth rate of an algorithm's time or space requirements as the input size increases.\n\nExample: If we have a function `f(n) = 3n^2 + 2n + 1`, its Big-O notation is `O(n^2)`. This means that for large values of `n`, the function grows no faster than some constant multiple of `n^2`.", "citations": "", "retrieved_chunks": "", "latency_s": 15.301}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "algo-notes", "pdf_name": "ALGORTIHM-SHORT-NOTES-_compressed.pdf", "pages": 21, "question_id": "algo_q3", "question": "Define Big-O notation with an example.", "expected": "- Represents asymptotic upper bound\n- Describes worst-case complexity\n- Ignores constants and lower-order terms", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Big-O notation, pronounced \"big-oh,\" is used to describe the upper bound of an algorithm's running time or space requirements as the input size grows. Formally, for functions f(n) and g(n), we say that f(n) = O(g(n)) if there exist positive constants c > 0 and n0 ≥ 1 such that f(n) ≤ c . g(n) for all n ≥ n0.\n\nFor example, consider the function T(n) which represents the time complexity of an algorithm. If T(n) = 3n^2 + 2n + 5, we can say that T(n) is O(n^2). This means there exist constants c and n0 such that for all n ≥ n0, the value of 3n^2 + 2n + 5 does not exceed some constant multiple (c . g(n)) of n^2. In this case, we can choose c = 4 and n0 = 1, because for all n ≥ 1, 3n^2 + 2n + 5 ≤ 4n^2.", "citations": "p11:c2|p5:c0|p3:c0|p2:c1|p16:c1", "retrieved_chunks": "p11: work on only one activity at a time (i.e., no overlapping activities). Sort the activities by their finishing time (in ascending order). Select the first activity in the sorted list and include it in the final solution. Iterate through the remaining activities in the sorted list: ALGORITHMS GATE फर्रे  Page No:- 09 | p5: Discrete Properties of Asymptotic Notation  Analogy between real no & asymptotic notation  Let a, b are two real no & f, g two positive functions  ● If f(n) is O(g(n)) : a ≤ b (f grows slower than some multiple of g) ● If f(n) is Ω(g(n)) : a ≥ b (f grows faster than some multiple of g) ● If f(n) is Θ(g(n)) : a = b (f grows at same rate of g) ● If f(n) is o(g(n)) : a < b (f grows slower than any multiple of g) ● If f(n) is ω(g(n)) : a > b (f grows faster than any multi", "latency_s": 116.5395}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "algo-notes", "pdf_name": "ALGORTIHM-SHORT-NOTES-_compressed.pdf", "pages": 21, "question_id": "algo_q4", "question": "What does Θ-notation represent in asymptotic analysis?", "expected": "- Represents tight bound\n- Gives exact order of growth\n- Upper and lower bounds are same", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Θ-notation represents the tight bound or tight asymptotic notation of an algorithm's running time or space complexity. It describes the function that both upper and lower bounds the algorithm's resource usage, indicating the worst-case scenario that is neither too loose nor too tight.", "citations": "", "retrieved_chunks": "", "latency_s": 8.6319}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "algo-notes", "pdf_name": "ALGORTIHM-SHORT-NOTES-_compressed.pdf", "pages": 21, "question_id": "algo_q4", "question": "What does Θ-notation represent in asymptotic analysis?", "expected": "- Represents tight bound\n- Gives exact order of growth\n- Upper and lower bounds are same", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Θ-notation represents a tight bound on the growth rate of a function. Specifically, it indicates that the function \\( f(n) \\) grows at the same rate as \\( g(n) \\). Mathematically, this is expressed as:\n\n\\[ f(n) = \\theta(g(n)) \\text{ if and only if } f(n) \\leq c_1 . g(n) \\text{ and } f(n) \\geq c_2 . g(n) \\forall n \\geq n_0 \\]\n\nwhere \\( c_1 > 0 \\), \\( c_2 > 0 \\), and \\( n_0 \\geq 1 \\) are positive constants. This means that there exist positive constants such that \\( f(n) \\) is both upper-bounded and lower-bounded by a constant multiple of \\( g(n) \\).", "citations": "p5:c0|p3:c0|p11:c2|p2:c1|p2:c0", "retrieved_chunks": "p5: Discrete Properties of Asymptotic Notation  Analogy between real no & asymptotic notation  Let a, b are two real no & f, g two positive functions  ● If f(n) is O(g(n)) : a ≤ b (f grows slower than some multiple of g) ● If f(n) is Ω(g(n)) : a ≥ b (f grows faster than some multiple of g) ● If f(n) is Θ(g(n)) : a = b (f grows at same rate of g) ● If f(n) is o(g(n)) : a < b (f grows slower than any multiple of g) ● If f(n) is ω(g(n)) : a > b (f grows faster than any multiple of g) Analysis 1. f(n) = n! n! <= c*n^n : n >= 2 n! = O(n^n) with c = 1, n0 = 2. using stirling’s approximation : n! ≈ √(2nπ) n^n * e ^ -n Trichotomy property: For any two real numbers (a, b) there must be a relation between them (a > b, a < b, a = b) Asymptotic notation does not satisfy trichotomy property Ex: f(n) = ", "latency_s": 121.4151}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "algo-notes", "pdf_name": "ALGORTIHM-SHORT-NOTES-_compressed.pdf", "pages": 21, "question_id": "algo_q5", "question": "Explain Ω-notation and its significance.", "expected": "- Represents asymptotic lower bound\n- Describes best-case performance\n- Shows minimum time requirement", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Ω-notation is used in computer science to describe the lower bound of an algorithm's running time or space complexity. It tells us the best-case scenario for how fast an algorithm can run, meaning it gives a threshold below which the runtime will not fall. This notation is significant for understanding the minimum resources required by an algorithm as the input size grows.", "citations": "", "retrieved_chunks": "", "latency_s": 10.7073}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "algo-notes", "pdf_name": "ALGORTIHM-SHORT-NOTES-_compressed.pdf", "pages": 21, "question_id": "algo_q5", "question": "Explain Ω-notation and its significance.", "expected": "- Represents asymptotic lower bound\n- Describes best-case performance\n- Shows minimum time requirement", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "The context provided does not contain an explicit explanation of Ω-notation. The closest related information is found in Source 3, Page 5, Chunk 0, which states:\n\n● If f(n) is Ω(g(n)) : a ≥ b (f grows faster than some multiple of g)\n\nThis definition indicates that if function f(n) is Ω(g(n)), it means that f(n) grows at least as fast as g(n), but it does not provide an in-depth explanation of the significance or full details of Ω-notation.\n\nTo fully explain Ω-notation and its significance, we would need additional context beyond what is provided. However, based on common knowledge:\n\nΩ-notation (Big Omega notation) is used in computer science to describe the lower bound of a function's complexity. It represents the best-case scenario for how fast or slow an algorithm can run. Specifically:\n- f(n) = Ω(g(n)) means there exist positive constants c and n0 such that 0 ≤ cg(n) ≤ f(n) for all n ≥ n0.\n- This indicates that f(n) grows at least as fast as g(n).\n\nThe significance of Ω-notation lies in its ability to provide a lower bound on the growth rate of an algorithm, which helps in understanding the minimum resources required by an algorithm. It complements other notations like Big O and Theta notation to give a more complete picture of an algorithm's complexity.", "citations": "p11:c2|p3:c0|p5:c0|p16:c1|p12:c2", "retrieved_chunks": "p11: work on only one activity at a time (i.e., no overlapping activities). Sort the activities by their finishing time (in ascending order). Select the first activity in the sorted list and include it in the final solution. Iterate through the remaining activities in the sorted list: ALGORITHMS GATE फर्रे  Page No:- 09 | p3: Asymptotic notation does not satisfy trichotomy  property  ex: f(n) = n, g(n) = n * |sin(n)|, n > 0  ∴ These two functions cannot converge  Example  1. Loop for ( i = 1; i <= n; i++) {  x=y+z;  }  T(n) = O(n)  2. Nested loop for(i=1; i<=n; i++){  for(j=1; j<=n; j++){  k= k+1;  }  }  T(n) = O(n2)  3. Logarithm for(i=1; i<=n ; i *= 2){  k=k+1;  }  for (int i = 1; i <= n; i++) {      for (int j = 1; j <= n; j *= 2) {    printf(“GFG”);      }  }  T(n) = O(n log n)  4. Lin", "latency_s": 110.7577}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "algo-notes", "pdf_name": "ALGORTIHM-SHORT-NOTES-_compressed.pdf", "pages": 21, "question_id": "algo_q6", "question": "Why does asymptotic notation not satisfy the trichotomy property?", "expected": "- Functions may not strictly dominate each other\n- Oscillating functions violate comparison\n- Upper and lower bounds may overlap", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Asymptotic notation does not satisfy the trichotomy property because it is designed to describe the growth rate of functions rather than their strict ordering. Trichotomy requires that for any two elements, one must be less than, equal to, or greater than the other. Asymptotic notations like Big O, Omega, and Theta provide bounds on function growth but do not always allow us to definitively compare functions in a trichotomous manner due to their focus on upper or lower bounds rather than exact values.", "citations": "", "retrieved_chunks": "", "latency_s": 15.6564}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "algo-notes", "pdf_name": "ALGORTIHM-SHORT-NOTES-_compressed.pdf", "pages": 21, "question_id": "algo_q6", "question": "Why does asymptotic notation not satisfy the trichotomy property?", "expected": "- Functions may not strictly dominate each other\n- Oscillating functions violate comparison\n- Upper and lower bounds may overlap", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Asymptotic notation does not satisfy the trichotomy property because for any two real numbers \\(a\\) and \\(b\\), there must be a relation between them (i.e., \\(a > b\\), \\(a < b\\), or \\(a = b\\)). However, with asymptotic notation, this is not always the case. The context provides an example to illustrate this:\n\nFor functions \\(f(n) = n\\) and \\(g(n) = n^{| \\sin(n) |}\\) where \\(n > 0\\), these two functions cannot be compared using the trichotomy property of asymptotic notation because their growth rates do not consistently follow one of the possible relations (less than, equal to, or greater than). Therefore, they \"cannot converge\" in terms of a clear ordering under asymptotic analysis.", "citations": "p3:c0|p5:c0|p2:c1|p5:c1|p4:c0", "retrieved_chunks": "p3: Asymptotic notation does not satisfy trichotomy  property  ex: f(n) = n, g(n) = n * |sin(n)|, n > 0  ∴ These two functions cannot converge  Example  1. Loop for ( i = 1; i <= n; i++) {  x=y+z;  }  T(n) = O(n)  2. Nested loop for(i=1; i<=n; i++){  for(j=1; j<=n; j++){  k= k+1;  }  }  T(n) = O(n2)  3. Logarithm for(i=1; i<=n ; i *= 2){  k=k+1;  }  for (int i = 1; i <= n; i++) {      for (int j = 1; j <= n; j *= 2) {    printf(“GFG”);      }  }  T(n) = O(n log n)  4. Linear recursion: void fun(int n) {      if (n > 0) {    fun(n - 1);      }  }  T(n) = T(n-1) + C  T(n) = O(n)  5. Recursive with logarithmic loop void fun(int n) {      if (n > 1) {    fun(n / 2);           // Recursive call first     for (int i = 1; i <= n; i *= 2) {   printf(\"Hello\\n\");    }      }  }  T(n) =  T(n/2) + O(l", "latency_s": 136.126}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "algo-notes", "pdf_name": "ALGORTIHM-SHORT-NOTES-_compressed.pdf", "pages": 21, "question_id": "algo_q7", "question": "Find the time complexity of a single nested loop running n×n times.", "expected": "- Outer loop runs n times\n- Inner loop runs n times\n- Overall time complexity is O(n²)", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "The time complexity of a single nested loop running \\( n \\times n \\) times is \\( O(n^2) \\).", "citations": "", "retrieved_chunks": "", "latency_s": 5.6038}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "algo-notes", "pdf_name": "ALGORTIHM-SHORT-NOTES-_compressed.pdf", "pages": 21, "question_id": "algo_q7", "question": "Find the time complexity of a single nested loop running n×n times.", "expected": "- Outer loop runs n times\n- Inner loop runs n times\n- Overall time complexity is O(n²)", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "The context provided does not contain information about a single nested loop running \\( n \\times n \\) times. The closest relevant piece of information given is from [Source 2, Page 3, Chunk 1], which describes the time complexity for a specific nested loop structure:\n\n```\nfor (j = 1; j <= n; ++j) // Executes 'n' times  \nfor (k = n/2; k <= n; k += n/2) // Executes 2 times (n/2, \nn)  \nC = C + H; \nTime  = O(n^2)\n```\n\nThis example shows a nested loop structure that results in \\( O(n^2) \\) time complexity. However, this is not exactly the same as a single nested loop running \\( n \\times n \\) times.\n\nFor a single nested loop running \\( n \\times n \\) times (i.e., a double nested loop where both loops run from 1 to \\( n \\)), the time complexity would be:\n\n```\nfor(i=1;i<=n;i++) {\n    for(j=1;j<=n;j++) {\n        // some operation\n    }\n}\nTime complexity: O(n^2)\n```", "citations": "p12:c0|p3:c1|p11:c1|p12:c2|p8:c1", "retrieved_chunks": "p12: ● For each activity, check if its start time is greater than or equal to the finish time of the last selected activity. ● If the condition holds, select the activity and update the last selected finish time. Time complexity  If activities are not sorted by finish time:  ● Sorting takes O(nlog⁡n) ● Selecting activities takes O(n)O(n)O(n) ● Total time = O(nlog⁡n) If activities are sorted by finish time: ● Only the selection loop runs → O(n) ● Total time = O(n) 5. Minimum cost spanning tree I. Kruskal’s Minimum spanning tree algorithm It builds the Minimum Spanning Tree by always choosing the next lightest edge that doesn't form a cycle. Sort all edges of the graph in non-decreasing order of their weights. Initialize an empty set for the MST. For each edge in the sorted list: ● If the ed", "latency_s": 112.128}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "algo-notes", "pdf_name": "ALGORTIHM-SHORT-NOTES-_compressed.pdf", "pages": 21, "question_id": "algo_q8", "question": "What is the time complexity of a loop where the iterator doubles each iteration?", "expected": "- Iterator grows exponentially\n- Number of iterations is log₂n\n- Time complexity is O(log n)", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "The time complexity of a loop where the iterator doubles each iteration is O(log n), where n is the number of iterations needed to reach or exceed the target value.", "citations": "", "retrieved_chunks": "", "latency_s": 6.4897}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "algo-notes", "pdf_name": "ALGORTIHM-SHORT-NOTES-_compressed.pdf", "pages": 21, "question_id": "algo_q8", "question": "What is the time complexity of a loop where the iterator doubles each iteration?", "expected": "- Iterator grows exponentially\n- Number of iterations is log₂n\n- Time complexity is O(log n)", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "The time complexity of a loop where the iterator doubles each iteration, such as `for (i=1; i<=n; i=i*2)`, is \\( O(\\log n) \\). This follows from the general formula provided in the context for multiplicative increment loops.", "citations": "p3:c1|p12:c0|p12:c2|p11:c1|p3:c0", "retrieved_chunks": "p3: for (j = 1; j <= n; ++j) // Executes 'n' times   for (k = n/2; k <= n; k += n/2) // Executes 2 times (n/2,  n)   C = C + H;  Time  = O(n 2)  for(i=1;i<n;i = i+a)  Time : O(n/a) = O(n)  9. For a loop with a multiplicative increment: for (i=1;i<=n;i=i∗2): This loop's complexity is Log2n.  for (i=1;i<=n;i=i∗3): This loop's complexity is Log3n.  for (i=1;i<=n;i=i∗a);  General formula: The time complexity is  O(logan).  k=1, i=1  while(k<=n){  i++;  k=k+i;  }  Time complexity : T(n) = O(√n)  for (i = n; i >= 2; i = sqrt(i))  Time complexity: O(log log n).  10. for (i = 2; i <= n; i++) { // log logn for (j = 1; j <= i; j++) {  for (k = 1; k <= n; k +=j) { // n/j ,  where j = 1,2,3,..n  x = y + z;  ...  }  }  }  T(m) = O(log logn (n logn))  ALGORITHMS GATE फर्रे  Page No:- 02 | p12: ● For eac", "latency_s": 93.3447}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "algo-notes", "pdf_name": "ALGORTIHM-SHORT-NOTES-_compressed.pdf", "pages": 21, "question_id": "algo_q9", "question": "Write the recurrence relation for a divide-and-conquer algorithm.", "expected": "- Problem divided into subproblems\n- General form: T(n) = aT(n/b) + f(n)\n- Used in merge sort, binary search", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "T(n) = 2T(n/2) + Θ(1)", "citations": "", "retrieved_chunks": "", "latency_s": 4.2262}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "algo-notes", "pdf_name": "ALGORTIHM-SHORT-NOTES-_compressed.pdf", "pages": 21, "question_id": "algo_q9", "question": "Write the recurrence relation for a divide-and-conquer algorithm.", "expected": "- Problem divided into subproblems\n- General form: T(n) = aT(n/b) + f(n)\n- Used in merge sort, binary search", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "A general recurrence relation for a divide-and-conquer algorithm can be written as:\n\n\\[ T(n) = aT\\left(\\frac{n}{b}\\right) + f(n) \\]\n\nwhere:\n- \\(a \\geq 1\\) is the number of subproblems in the recursion.\n- \\(\\frac{n}{b}\\) is the size of each subproblem. (Note: In practice, this might be adjusted based on how the problem is divided.)\n- \\(f(n)\\) represents the cost of the work done outside the recursive calls, including the cost of dividing the problem and combining the results.\n\nThis recurrence relation fits various divide-and-conquer algorithms like merge sort, quicksort, and matrix multiplication.", "citations": "p4:c0|p3:c0|p5:c0|p12:c2|p8:c0", "retrieved_chunks": "p4: Master Theorem:  Let f(n) is a positive function and T (n) is defined  recurrence relation:    T(n) = aT(n/b) + f(n)  Where a >= 1 and b > 1 are two positive constants.  Case 1:   If f(n) = O(n(logb a−∈)) for some constant ∈ > o then T(n)  = θ (n(logb a) )  Case 2:  If f(n) = θ (n(logb a) ), then T(n) = θ (n(logb a) *log n)  Case 3:  If f(n) = Ω (n(logb a+∈)) for some constant ∈> 0, and if a f (n/b) ≤ cf(n) for some constant c < 1 and all  sufficiently large n, then T(n) = θ(f(n))  Master theorem for subtract and conquer  recurrence:  Let T(n) be a function defined on possible n:  T(n) = aT(n-b) + f(n), if n > 1  T(n) = C, if n <= 1  For some constant C,  a>0, b>0, and f(n) = O(nd)  1. T(n) = O(nd) , if a < 1 2. T(n) = O(nd+1) , if a = 1 3. T(n) = O(nd * a(n/b)) , if a > 1 Common Recur", "latency_s": 130.4498}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "algo-notes", "pdf_name": "ALGORTIHM-SHORT-NOTES-_compressed.pdf", "pages": 21, "question_id": "algo_q10", "question": "State the Master Theorem and its three cases.", "expected": "- Used to solve divide-and-conquer recurrences\n- Case 1: f(n) smaller than n^logb(a)\n- Case 2: f(n) equal to n^logb(a)\n- Case 3: f(n) larger than n^logb(a)", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "The Master Theorem applies to divide-and-conquer algorithms described by recurrence relations of the form:\n\n\\[ T(n) = aT\\left(\\frac{n}{b}\\right) + f(n) \\]\n\nwhere \\(a \\geq 1\\), \\(b > 1\\), and \\(f(n)\\) is an asymptotically positive function.\n\nThe theorem has three cases:\n\n1. If \\(f(n) = O(n^c)\\) where \\(c < \\log_b a\\), then \\(T(n) = \\Theta(n^{\\log_b a})\\).\n\n2. If \\(f(n) = \\Theta(n^c)\\) where \\(c = \\log_b a\\), then \\(T(n) = \\Theta(n^c \\log n)\\).\n\n3. If \\(f(n) = \\Omega(n^c)\\) where \\(c > \\log_b a\\) and if \\(af\\left(\\frac{n}{b}\\right) \\leq kf(n)\\) for some constant \\(k < 1\\) and sufficiently large \\(n\\), then \\(T(n) = \\Theta(f(n))\\).", "citations": "", "retrieved_chunks": "", "latency_s": 31.2829}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "algo-notes", "pdf_name": "ALGORTIHM-SHORT-NOTES-_compressed.pdf", "pages": 21, "question_id": "algo_q10", "question": "State the Master Theorem and its three cases.", "expected": "- Used to solve divide-and-conquer recurrences\n- Case 1: f(n) smaller than n^logb(a)\n- Case 2: f(n) equal to n^logb(a)\n- Case 3: f(n) larger than n^logb(a)", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "The provided context does not contain information about the Master Theorem or its cases. Therefore, I cannot state the Master Theorem based on this given context alone.", "citations": "p11:c2|p5:c0|p11:c0|p2:c1|p3:c0", "retrieved_chunks": "p11: work on only one activity at a time (i.e., no overlapping activities). Sort the activities by their finishing time (in ascending order). Select the first activity in the sorted list and include it in the final solution. Iterate through the remaining activities in the sorted list: ALGORITHMS GATE फर्रे  Page No:- 09 | p5: Discrete Properties of Asymptotic Notation  Analogy between real no & asymptotic notation  Let a, b are two real no & f, g two positive functions  ● If f(n) is O(g(n)) : a ≤ b (f grows slower than some multiple of g) ● If f(n) is Ω(g(n)) : a ≥ b (f grows faster than some multiple of g) ● If f(n) is Θ(g(n)) : a = b (f grows at same rate of g) ● If f(n) is o(g(n)) : a < b (f grows slower than any multiple of g) ● If f(n) is ω(g(n)) : a > b (f grows faster than any multi", "latency_s": 97.2342}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "algo-notes", "pdf_name": "ALGORTIHM-SHORT-NOTES-_compressed.pdf", "pages": 21, "question_id": "algo_q11", "question": "Solve T(n) = 2T(n/2) + n using Master Theorem.", "expected": "- a = 2, b = 2, f(n) = n\n- Falls under Case 2\n- Time complexity is O(n log n)", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Using the Master Theorem for the recurrence relation \\( T(n) = 2T(n/2) + n \\):\n\n- \\( a = 2 \\)\n- \\( b = 2 \\)\n- \\( f(n) = n \\)\n\nWe compare \\( f(n) \\) with \\( n^{\\log_b{a}} \\):\n- \\( n^{\\log_b{a}} = n^{\\log_2{2}} = n^1 = n \\)\n\nSince \\( f(n) = n \\) is \\( \\Theta(n^{\\log_b{a}}) \\), this falls under Master Theorem case 2, where the solution is \\( T(n) = \\Theta(n \\log n) \\).", "citations": "", "retrieved_chunks": "", "latency_s": 21.0966}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "algo-notes", "pdf_name": "ALGORTIHM-SHORT-NOTES-_compressed.pdf", "pages": 21, "question_id": "algo_q11", "question": "Solve T(n) = 2T(n/2) + n using Master Theorem.", "expected": "- a = 2, b = 2, f(n) = n\n- Falls under Case 2\n- Time complexity is O(n log n)", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "To solve the recurrence relation \\( T(n) = 2T(n/2) + n \\) using the Master Theorem, we need to compare it with the general form of a divide-and-conquer recurrence relation:\n\n\\[ T(n) = aT\\left(\\frac{n}{b}\\right) + f(n) \\]\n\nHere:\n- \\( a = 2 \\)\n- \\( b = 2 \\)\n- \\( f(n) = n \\)\n\nNext, we need to determine which case of the Master Theorem applies:\n\n1. **Case 1**: If \\( f(n) = O(n^{\\log_b a - \\epsilon}) \\) for some constant \\( \\epsilon > 0 \\), then \\( T(n) = \\Theta(n^{\\log_b a}) \\).\n\n2. **Case 2**: If \\( f(n) = \\Theta(n^{\\log_b a}) \\), then \\( T(n) = \\Theta(n^{\\log_b a} \\cdot \\log n) \\).\n\n3. **Case 3**: If \\( f(n) = \\Omega(n^{\\log_b a + \\epsilon}) \\) for some constant \\( \\epsilon > 0 \\), and if \\( af\\left(\\frac{n}{b}\\right) \\leq cf(n) \\) for some constant \\( c < 1 \\) and all sufficiently large \\( n \\), then \\( T(n) = \\Theta(f(n)) \\).\n\nFor our recurrence relation:\n- \\( a = 2 \\)\n- \\( b = 2 \\)\n- \\( f(n) = n \\)\n\nWe have:\n\n\\[ \\log_b a = \\log_2 2 = 1 \\]\n\nNow, we compare \\( f(n) = n \\) with \\( n^{\\log_b a} = n^1 = n \\):\n\n- Since \\( f(n) = n = n^1 \\), this fits the condition for **Case 2** of the Master Theorem.\n\nTherefore, according to Case 2:\n\n\\[ T(n) = \\Theta(n^{\\log_b a} \\cdot \\log n) = \\Theta(n \\cdot \\log n) \\]\n\nSo, the solution to the recurrence relation \\( T(n) = 2T(n/2) + n \\) is:\n\n\\[ T(n) = \\Theta(n \\log n) \\]", "citations": "p5:c0|p3:c0|p4:c1|p8:c0|p4:c0", "retrieved_chunks": "p5: Discrete Properties of Asymptotic Notation  Analogy between real no & asymptotic notation  Let a, b are two real no & f, g two positive functions  ● If f(n) is O(g(n)) : a ≤ b (f grows slower than some multiple of g) ● If f(n) is Ω(g(n)) : a ≥ b (f grows faster than some multiple of g) ● If f(n) is Θ(g(n)) : a = b (f grows at same rate of g) ● If f(n) is o(g(n)) : a < b (f grows slower than any multiple of g) ● If f(n) is ω(g(n)) : a > b (f grows faster than any multiple of g) Analysis 1. f(n) = n! n! <= c*n^n : n >= 2 n! = O(n^n) with c = 1, n0 = 2. using stirling’s approximation : n! ≈ √(2nπ) n^n * e ^ -n Trichotomy property: For any two real numbers (a, b) there must be a relation between them (a > b, a < b, a = b) Asymptotic notation does not satisfy trichotomy property Ex: f(n) = ", "latency_s": 201.0816}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "algo-notes", "pdf_name": "ALGORTIHM-SHORT-NOTES-_compressed.pdf", "pages": 21, "question_id": "algo_q12", "question": "What is meant by time complexity being infinite?", "expected": "- Algorithm never terminates\n- Occurs due to infinite loop\n- Time complexity is unbounded", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Time complexity cannot be infinite in practical algorithms. It typically describes how the runtime grows with input size, bounded below some function. Infinite time complexity would imply an algorithm runs forever, which isn't useful or realistic.", "citations": "", "retrieved_chunks": "", "latency_s": 7.2068}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "algo-notes", "pdf_name": "ALGORTIHM-SHORT-NOTES-_compressed.pdf", "pages": 21, "question_id": "algo_q12", "question": "What is meant by time complexity being infinite?", "expected": "- Algorithm never terminates\n- Occurs due to infinite loop\n- Time complexity is unbounded", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "The provided context does not contain any information about time complexity being infinite. Therefore, based on the given context, I cannot provide an answer to what is meant by time complexity being infinite. The context discusses time complexities like O(n), O(n log n), O(E log E) or O(E log V), and other specific cases but does not mention anything about infinite time complexity.", "citations": "p12:c0|p11:c0|p5:c1|p6:c0|p3:c1", "retrieved_chunks": "p12: ● For each activity, check if its start time is greater than or equal to the finish time of the last selected activity. ● If the condition holds, select the activity and update the last selected finish time. Time complexity  If activities are not sorted by finish time:  ● Sorting takes O(nlog⁡n) ● Selecting activities takes O(n)O(n)O(n) ● Total time = O(nlog⁡n) If activities are sorted by finish time: ● Only the selection loop runs → O(n) ● Total time = O(n) 5. Minimum cost spanning tree I. Kruskal’s Minimum spanning tree algorithm It builds the Minimum Spanning Tree by always choosing the next lightest edge that doesn't form a cycle. Sort all edges of the graph in non-decreasing order of their weights. Initialize an empty set for the MST. For each edge in the sorted list: ● If the ed", "latency_s": 73.8101}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "algo-notes", "pdf_name": "ALGORTIHM-SHORT-NOTES-_compressed.pdf", "pages": 21, "question_id": "algo_q13", "question": "Explain mutually exclusive loops with an example.", "expected": "- Only one loop executes at a time\n- Loops do not overlap in execution\n- Time complexity is max of loops", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Mutually exclusive loops refer to situations where two or more loops cannot run simultaneously due to shared resources or conditions. An example is a multi-threaded program where multiple threads attempt to access and modify a shared resource like a database.\n\nExample:\n```python\nimport threading\n\ndatabase = []\n\ndef thread_function():\n    global database\n    # Simulate reading from the database\n    read_data = [1, 2, 3]\n    \n    # Mutually exclusive loop\n    for item in read_data:\n        with lock:  # Assume 'lock' is a shared lock object\n            database.append(item)\n            print(f\"Added {item} to database\")\n\n# Create and start threads\nthread1 = threading.Thread(target=thread_function)\nthread2 = threading.Thread(target=thread_function)\n\nthread1.start()\nthread2.start()\n\nthread1.join()\nthread2.join()\n```\n\nIn this example, both threads attempt to modify the `database` list. Using a lock ensures that only one thread can execute the loop body at a time, making the loops mutually exclusive and preventing race conditions.", "citations": "", "retrieved_chunks": "", "latency_s": 29.0925}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "algo-notes", "pdf_name": "ALGORTIHM-SHORT-NOTES-_compressed.pdf", "pages": 21, "question_id": "algo_q13", "question": "Explain mutually exclusive loops with an example.", "expected": "- Only one loop executes at a time\n- Loops do not overlap in execution\n- Time complexity is max of loops", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Mutually exclusive loops occur when the execution of one loop is independent of another, meaning they do not share any variables or operations that affect their execution. The time complexity for such cases can be determined by considering the maximum of the individual complexities of each loop.\n\nExample from the context:\n1. For i←1 to n: C=C+1;\n2. For j←1 to m: K=K∗2;\n\nIn this example, these two loops are mutually exclusive because they operate on different variables (C and K) and do not interfere with each other's execution. The time complexity for the first loop is O(n), and for the second loop, it is O(m). Therefore, the overall time complexity considering both loops is O(max(n, m)).", "citations": "p3:c0|p15:c0|p11:c2|p12:c2|p5:c0", "retrieved_chunks": "p3: Asymptotic notation does not satisfy trichotomy  property  ex: f(n) = n, g(n) = n * |sin(n)|, n > 0  ∴ These two functions cannot converge  Example  1. Loop for ( i = 1; i <= n; i++) {  x=y+z;  }  T(n) = O(n)  2. Nested loop for(i=1; i<=n; i++){  for(j=1; j<=n; j++){  k= k+1;  }  }  T(n) = O(n2)  3. Logarithm for(i=1; i<=n ; i *= 2){  k=k+1;  }  for (int i = 1; i <= n; i++) {      for (int j = 1; j <= n; j *= 2) {    printf(“GFG”);      }  }  T(n) = O(n log n)  4. Linear recursion: void fun(int n) {      if (n > 0) {    fun(n - 1);      }  }  T(n) = T(n-1) + C  T(n) = O(n)  5. Recursive with logarithmic loop void fun(int n) {      if (n > 1) {    fun(n / 2);           // Recursive call first     for (int i = 1; i <= n; i *= 2) {   printf(\"Hello\\n\");    }      }  }  T(n) =  T(n/2) + O(l", "latency_s": 89.7009}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "algo-notes", "pdf_name": "ALGORTIHM-SHORT-NOTES-_compressed.pdf", "pages": 21, "question_id": "algo_q14", "question": "What is space complexity and how is it different from auxiliary space?", "expected": "- Space complexity includes total memory used\n- Auxiliary space excludes input space\n- Auxiliary space is extra working memory", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Space complexity refers to the total amount of memory space an algorithm requires to run as a function of the input size. Auxiliary space is the extra or temporary space used by an algorithm, excluding the space taken by the input data.\n\nThe key difference is:\n- Space complexity includes all space required during execution.\n- Auxiliary space only counts additional space beyond the input.", "citations": "", "retrieved_chunks": "", "latency_s": 10.943}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "algo-notes", "pdf_name": "ALGORTIHM-SHORT-NOTES-_compressed.pdf", "pages": 21, "question_id": "algo_q14", "question": "What is space complexity and how is it different from auxiliary space?", "expected": "- Space complexity includes total memory used\n- Auxiliary space excludes input space\n- Auxiliary space is extra working memory", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Space complexity refers to the total space required by an algorithm to solve an instance of a problem, excluding the space allocated to hold input. It includes both the constant space (C) and additional space that depends on the input size (S(n)).\n\nAuxiliary space is defined as the extra or temporary space used by the algorithm excluding the space required for input. In other words, auxiliary space does not include the space taken by the input itself but focuses solely on the additional space used during the execution of an algorithm.\n\nTo summarize:\n- Space complexity: Total space used including input = C + S(n)\n- Auxiliary space: Extra space used excluding the input", "citations": "p5:c1|p6:c0|p8:c1|p14:c0|p18:c0", "retrieved_chunks": "p5: f(n) = O(h(n)) Note : Ω and Θ also satisfy transitivity 4. Transpose Symmetric f(n) = O(g(n)) iff g(n) = Ω(f(n)) Best case(n) ≤ Average case(n) ≤ Worst case(n)  Space Complexity  Space required by algorithm to solve an instance of  the problem, excluding the space allocated to hold  input.   Space complexity : C + S(n)  C - Constant space  S(n) - Additional space that depends on input size n  Space Complexity VS Auxiliary space  Space Complexity = Total space used including input  Auxiliary space = Extra space used excluding the input  Property Big  Oh(O)  Big  Omega()  Theta() Small  oh(o)  Small  omega ()  Reflexive ✓ ✓ ✓ × ×  Symmetric × × ✓ × ×  Transitive ✓ ✓ ✓ ✓ ✓  Transpose  symmetric  ✓ ✓ × ✓ ✓  ALGORITHMS GATE फर्रे  Page No:- 04 | p6: Space Complexity (Memory)  Example:  Algo", "latency_s": 92.7746}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "algo-notes", "pdf_name": "ALGORTIHM-SHORT-NOTES-_compressed.pdf", "pages": 21, "question_id": "algo_q15", "question": "Give the time complexity of binary search and justify it.", "expected": "- Array is divided into half each step\n- Number of steps is log₂n\n- Time complexity is O(log n)", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "The time complexity of binary search is O(log n). This is because with each step, binary search halves the search space, leading to a logarithmic growth rate in the number of operations required as the input size increases.", "citations": "", "retrieved_chunks": "", "latency_s": 7.692}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "algo-notes", "pdf_name": "ALGORTIHM-SHORT-NOTES-_compressed.pdf", "pages": 21, "question_id": "algo_q15", "question": "Give the time complexity of binary search and justify it.", "expected": "- Array is divided into half each step\n- Number of steps is log₂n\n- Time complexity is O(log n)", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "The provided context does not contain the specific time complexity for binary search or any justification related to it. The context focuses on other algorithms such as activity selection, minimum cost spanning trees (Kruskal's and Prim's algorithms), optimal binary search tree construction, multistage graphs, greedy algorithms, and merge sort. Therefore, based on the given information, I cannot provide an answer about the time complexity of binary search or justify it.", "citations": "p12:c0|p14:c1|p11:c0|p11:c1|p8:c2", "retrieved_chunks": "p12: ● For each activity, check if its start time is greater than or equal to the finish time of the last selected activity. ● If the condition holds, select the activity and update the last selected finish time. Time complexity  If activities are not sorted by finish time:  ● Sorting takes O(nlog⁡n) ● Selecting activities takes O(n)O(n)O(n) ● Total time = O(nlog⁡n) If activities are sorted by finish time: ● Only the selection loop runs → O(n) ● Total time = O(n) 5. Minimum cost spanning tree I. Kruskal’s Minimum spanning tree algorithm It builds the Minimum Spanning Tree by always choosing the next lightest edge that doesn't form a cycle. Sort all edges of the graph in non-decreasing order of their weights. Initialize an empty set for the MST. For each edge in the sorted list: ● If the ed", "latency_s": 80.6927}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "ds-notes", "pdf_name": "DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "pages": 17, "question_id": "ds_q1", "question": "Define an array and mention two characteristics.", "expected": "- Collection of homogeneous elements\n- Stored in contiguous memory\n- Supports direct indexing", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "An array is a data structure that stores a collection of elements of the same type. Two characteristics are:\n1. Ordered collection\n2. Indexed access", "citations": "", "retrieved_chunks": "", "latency_s": 5.8175}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "ds-notes", "pdf_name": "DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "pages": 17, "question_id": "ds_q1", "question": "Define an array and mention two characteristics.", "expected": "- Collection of homogeneous elements\n- Stored in contiguous memory\n- Supports direct indexing", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "The context provided does not contain a specific definition of an array. However, based on the information given, we can infer two characteristics of an array:\n\n1. **Fixed Size**: Arrays have a fixed size, which means their capacity is determined at the time of creation and cannot be changed dynamically.\n2. **Contiguous Memory Locations**: Elements in an array are stored in contiguous memory locations, meaning each element occupies a consecutive block of memory.\n\nThese characteristics are implied from the context discussing arrays as part of queue implementations with fixed sizes.", "citations": "p5:c0|p3:c0|p4:c0|p9:c0|p8:c1", "retrieved_chunks": "p5: Operation Description Time  Complexity  enqueue(x) Insert  element x at  the rear  O (1) (array  or LL)  dequeue() Remove  and return  element  from front  O (1)  • Type • Description • Simple Queue • Basic FIFO queue (insertion at rear, deletion at front) • Circular Queue • Last position connects back to first (solves overflow in array) • Deque (Double- Ended Queue) • Insertion/deletion possible from both ends • Priority Queue • Elements served based on priority, not position In a simple/linear queue using array, after a few  enqueue and dequeue operations:  • The front moves ahead • But rear reaches the end of array • Even though free space exists at the beginning, we can't use it This leads to a false overflow.   Solution:  In a circular queue, we connect the rear back to  front, fo", "latency_s": 69.6848}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "ds-notes", "pdf_name": "DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "pages": 17, "question_id": "ds_q2", "question": "What is a sparse matrix?", "expected": "- Matrix with more zero elements\n- Zero elements > non-zero elements\n- Memory-efficient representation", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "A sparse matrix is a matrix in which most of the elements have zero values. It contains few non-zero elements compared to the total number of elements in the matrix. Sparse matrices are often used in situations where memory usage and computational efficiency are important considerations.", "citations": "", "retrieved_chunks": "", "latency_s": 8.2712}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "ds-notes", "pdf_name": "DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "pages": 17, "question_id": "ds_q2", "question": "What is a sparse matrix?", "expected": "- Matrix with more zero elements\n- Zero elements > non-zero elements\n- Memory-efficient representation", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "A sparse matrix is a matrix in which most of the elements are zero. If the number of zero elements is greater than the number of non-zero elements, the matrix is considered sparse.", "citations": "p3:c0|p13:c1|p15:c0|p2:c1|p2:c0", "retrieved_chunks": "p3: Tridiagonal matrix  A tridiagonal matrix is a square matrix where non- zero elements exist only on the main diagonal, just  above it, and just below it.  A[i][j] ≠ 0 only if i == j, i == j+1, or i == j–1  Else, A[i][j] = 0  Sum of all the element is 3n-2.  A linked list is a linear data structure where elements  (called nodes) are stored in non-contiguous memory  locations and connected using pointers.  Each node contains:  • Data • Pointer (next) to the next node Advantages:  • Dynamic size (unlike arrays) • Efficient insertions/deletions (at beginning/middle) Disadvantages:  • No random access (O(n) access time) • Extra memory for pointers Stack   A stack is a linear data structure that follows the LIFO  principle  Last In, First Out  The last inserted element is the first to be remo", "latency_s": 62.29}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "ds-notes", "pdf_name": "DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "pages": 17, "question_id": "ds_q3", "question": "Differentiate between lower and upper triangular matrices.", "expected": "- Lower: elements above diagonal are zero\n- Upper: elements below diagonal are zero\n- Both must be square matrices", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "In a lower triangular matrix, all elements above the main diagonal are zero. In an upper triangular matrix, all elements below the main diagonal are zero.", "citations": "", "retrieved_chunks": "", "latency_s": 5.7937}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "ds-notes", "pdf_name": "DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "pages": 17, "question_id": "ds_q3", "question": "Differentiate between lower and upper triangular matrices.", "expected": "- Lower: elements above diagonal are zero\n- Upper: elements below diagonal are zero\n- Both must be square matrices", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "An upper triangular matrix is characterized by having all elements below the main diagonal equal to zero. Specifically, for an upper triangular matrix \\(A\\), the condition \\(A[i][j] = 0\\) holds for all indices where \\(i > j\\). This means that only elements on or above the main diagonal can be non-zero.\n\nIn contrast, a lower triangular matrix has all elements above the main diagonal equal to zero. For a lower triangular matrix, the condition \\(A[i][j] = 0\\) applies for all indices where \\(i < j\\), meaning that only elements on or below the main diagonal can be non-zero.\n\nBoth upper and lower triangular matrices must be square matrices (n × n).", "citations": "p2:c1|p3:c0|p9:c0|p7:c1|p8:c0", "retrieved_chunks": "p2: all elements above the main diagonal are zero.  A[i][j] = 0 for all i < j   Must be square (n × n).   Non-zero elements are on or below the main  diagonal.  Upper Triangular Matrix  An upper triangular matrix is a square matrix in  which all elements below the main diagonal are  zero.  A[i][j] = 0 for all i > j   Must be a square matrix (n × n)   Only elements on or above the main diagonal can be  non-zero  Elements below the diagonal are always zero  Operation Time  Complexity  Explanation  Access O (1) Direct access using index:  arr[i] → CPU calculates the  address directly using  formula Base + i * size  Insertion O (n) If insertion is at beginning  or middle, all subsequent  elements must be shifted  right  Deletion O (n) If deleting from start or  middle, elements must be  shifte", "latency_s": 72.7059}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "ds-notes", "pdf_name": "DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "pages": 17, "question_id": "ds_q4", "question": "What is a linked list and why is it preferred over arrays?", "expected": "- Nodes linked using pointers\n- Dynamic memory allocation\n- Efficient insertion and deletion", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "A linked list is a linear data structure where each element (node) points to the next node in the sequence. It's preferred over arrays for dynamic size, easier insertion/deletion operations, and better performance in scenarios with frequent modifications.", "citations": "", "retrieved_chunks": "", "latency_s": 8.2187}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "ds-notes", "pdf_name": "DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "pages": 17, "question_id": "ds_q4", "question": "What is a linked list and why is it preferred over arrays?", "expected": "- Nodes linked using pointers\n- Dynamic memory allocation\n- Efficient insertion and deletion", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "A linked list is a linear data structure where elements (called nodes) are stored in non-contiguous memory locations and connected using pointers. Each node contains:\n- Data\n- A pointer (next) to the next node.\n\nLinked lists are preferred over arrays because they offer dynamic size capabilities and efficient insertions/deletions at the beginning or middle of the list, unlike arrays which require shifting elements when inserting or deleting in the middle. However, linked lists do not support random access as it requires traversing from the head to the desired element (O(n) time complexity), and they consume extra memory for pointers.", "citations": "p15:c0|p3:c0|p9:c0|p5:c0|p12:c1", "retrieved_chunks": "p15: Search: Hash the key to find the index, then  linearly search the linked list at that index.  Deletion: Hash the key, search the linked list, and  remove the node if found.  No Clustering: Since elements are in separate lists,  primary/secondary clustering does not occur.  Load Factor (λ): λ = n / m  (n = total elements, m = table size)  Performance depends on λ.  If load factor λ ≤ 1, then open addressing methods  (like linear probing, quadratic probing, or double  hashing) are efficient.  If λ > 1, then separate chaining is preferred, since  open addressing works best only when the table is  sparsely filled.  DATA STRUCTURE GATE फर्रे  Page No:- 13 | p3: Tridiagonal matrix  A tridiagonal matrix is a square matrix where non- zero elements exist only on the main diagonal, just  above ", "latency_s": 67.2314}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "ds-notes", "pdf_name": "DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "pages": 17, "question_id": "ds_q5", "question": "State two disadvantages of linked lists.", "expected": "- No random access\n- Extra memory for pointers", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Two disadvantages of linked lists are:\n1. Random access is not efficient.\n2. Requires more memory due to node overhead.", "citations": "", "retrieved_chunks": "", "latency_s": 5.0991}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "ds-notes", "pdf_name": "DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "pages": 17, "question_id": "ds_q5", "question": "State two disadvantages of linked lists.", "expected": "- No random access\n- Extra memory for pointers", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Two disadvantages of linked lists are:\n1. No random access (O(n) access time)\n2. Extra memory for pointers", "citations": "p15:c0|p3:c0|p4:c0|p9:c0|p5:c0", "retrieved_chunks": "p15: Search: Hash the key to find the index, then  linearly search the linked list at that index.  Deletion: Hash the key, search the linked list, and  remove the node if found.  No Clustering: Since elements are in separate lists,  primary/secondary clustering does not occur.  Load Factor (λ): λ = n / m  (n = total elements, m = table size)  Performance depends on λ.  If load factor λ ≤ 1, then open addressing methods  (like linear probing, quadratic probing, or double  hashing) are efficient.  If λ > 1, then separate chaining is preferred, since  open addressing works best only when the table is  sparsely filled.  DATA STRUCTURE GATE फर्रे  Page No:- 13 | p3: Tridiagonal matrix  A tridiagonal matrix is a square matrix where non- zero elements exist only on the main diagonal, just  above ", "latency_s": 60.1388}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "ds-notes", "pdf_name": "DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "pages": 17, "question_id": "ds_q6", "question": "Define stack and list its basic operations.", "expected": "- Linear data structure\n- Follows LIFO principle\n- Operations: push, pop, peek", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "A stack is a linear data structure that follows the Last In First Out (LIFO) principle. Basic operations include:\n1. Push: Adds an element to the top of the stack.\n2. Pop: Removes the top element from the stack.\n3. Peek or Top: Returns the top element without removing it.\n4. IsEmpty: Checks if the stack is empty.\n5. Size: Returns the number of elements in the stack.", "citations": "", "retrieved_chunks": "", "latency_s": 13.4424}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "ds-notes", "pdf_name": "DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "pages": 17, "question_id": "ds_q6", "question": "Define stack and list its basic operations.", "expected": "- Linear data structure\n- Follows LIFO principle\n- Operations: push, pop, peek", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Based on the provided context:\n\nA Stack is a linear data structure that follows the Last In, First Out (LIFO) principle. The last element inserted will be the first to be removed.\n\nBasic Operations of a Stack:\n- **push(x)**: Inserts an element x at the top of the stack. Time Complexity: O(1)\n- **pop()**: Removes and returns the top element from the stack. Time Complexity: O(1)\n- **peek() / top()**: Returns the top element without removing it. Time Complexity: O(1)\n- **isEmpty()**: Checks if the stack is empty. Time Complexity: O(1)", "citations": "p4:c0|p12:c1|p8:c1|p9:c0|p5:c0", "retrieved_chunks": "p4: Implementation Methods:  1. Using Array (Fixed size, static memory) 2. Using Linked List (Dynamic size) Queue  A Queue is a linear data structure that follows the  FIFO principle:  First In, First Out  The first element inserted is the first to be removed.  Real-World Examples:  • Ticket line • Print queue CPU task scheduling  Operation Description Time  Complexity  push(x) Inserts element x at  the top  O(1)  pop() Removes and returns  top element  O(1)  peek() /  top()  Returns top element  without removing  O(1)  isEmpty() Checks if the stack is  empty  O(1)  Applications of Stack:  • Expression Evaluation & Conversion (Infix ↔ Postfix) • Balancing symbols (brackets, parentheses) • Function call tracking (recursion) • DFS traversal (graph) • Undo functionality • Backtracking (like m", "latency_s": 67.4662}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "ds-notes", "pdf_name": "DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "pages": 17, "question_id": "ds_q7", "question": "Explain the LIFO principle with an example.", "expected": "- Last inserted element removed first\n- Stack follows LIFO\n- Example: function calls", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "LIFO (Last In, First Out) is an inventory valuation method where the most recently stored items are sold or used first. For example, imagine a bakery that receives new loaves of bread every morning and sells them throughout the day. At the end of the day, they would sell the bread from today's batch before using any leftover bread from previous days, even if it's older.", "citations": "", "retrieved_chunks": "", "latency_s": 12.199}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "ds-notes", "pdf_name": "DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "pages": 17, "question_id": "ds_q7", "question": "Explain the LIFO principle with an example.", "expected": "- Last inserted element removed first\n- Stack follows LIFO\n- Example: function calls", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "The provided context does not contain any information about the LIFO principle. The context discusses data structures such as trees, heaps, and binary search trees, along with their properties and operations like inorder, preorder, and postorder traversals. It also mentions heap sort and time complexities but does not address the LIFO principle or provide an example related to it.\n\nTherefore, based on the given context, I cannot explain the LIFO principle with an example.", "citations": "p9:c0|p8:c1|p6:c1|p5:c1|p12:c1", "retrieved_chunks": "p9: Postorder  Left Subtree → Right Subtree → Node  Heap  A Heap is a special Complete Binary Tree where  every level is completely filled except possibly the last  level, and nodes are as far left as possible.   Min Heap  The value of each node is less than or equal to its  children.  |𝒂𝒂𝒌𝒌| < | left tree, right tree|  Root = Minimum element  postorder(node) {      if (node == NULL) return;      postorder(node->left);      postorder(node->right);      visit(node);  }  Postorder: 20 30 10  DATA STRUCTURE GATE फर्रे  Page No:- 08 | p8: inorder(node) {      if (node == NULL) return;      inorder(node->left);      visit(node);      inorder(node->right);  }  Inorder: 20 10 30  preorder(node) {      if (node == NULL) return;      visit(node);      preorder(node->left);      preorder(node->right", "latency_s": 52.6232}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "ds-notes", "pdf_name": "DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "pages": 17, "question_id": "ds_q8", "question": "What are the applications of stack data structure?", "expected": "- Expression evaluation\n- Function call management\n- Backtracking and undo operations", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Stacks are used in:\n1. Expression evaluation and syntax parsing\n2. Function call management in programming languages\n3. Backtracking algorithms\n4. Memory management\n5. Implementing undo/redo operations\n6. Depth-first search in graphs", "citations": "", "retrieved_chunks": "", "latency_s": 8.3701}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "ds-notes", "pdf_name": "DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "pages": 17, "question_id": "ds_q8", "question": "What are the applications of stack data structure?", "expected": "- Expression evaluation\n- Function call management\n- Backtracking and undo operations", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "The applications of stack data structure include:\n- Expression Evaluation & Conversion (Infix ↔ Postfix)\n- Balancing symbols (brackets, parentheses)\n- Function call tracking (recursion)\n- DFS traversal (graph)\n- Undo functionality\n- Backtracking (like maze, Sudoku)\n- Number of possible stack permutations", "citations": "p4:c0|p5:c1|p12:c1|p5:c0|p15:c0", "retrieved_chunks": "p4: Implementation Methods:  1. Using Array (Fixed size, static memory) 2. Using Linked List (Dynamic size) Queue  A Queue is a linear data structure that follows the  FIFO principle:  First In, First Out  The first element inserted is the first to be removed.  Real-World Examples:  • Ticket line • Print queue CPU task scheduling  Operation Description Time  Complexity  push(x) Inserts element x at  the top  O(1)  pop() Removes and returns  top element  O(1)  peek() /  top()  Returns top element  without removing  O(1)  isEmpty() Checks if the stack is  empty  O(1)  Applications of Stack:  • Expression Evaluation & Conversion (Infix ↔ Postfix) • Balancing symbols (brackets, parentheses) • Function call tracking (recursion) • DFS traversal (graph) • Undo functionality • Backtracking (like m", "latency_s": 64.6568}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "ds-notes", "pdf_name": "DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "pages": 17, "question_id": "ds_q9", "question": "Define a queue and explain FIFO.", "expected": "- Linear data structure\n- Follows FIFO principle\n- Insertion at rear, deletion at front", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "A queue is a linear data structure that follows the First-In-First-Out (FIFO) principle. FIFO means that the first element added to the queue will be the first one to be removed. Elements are inserted at the rear and removed from the front of the queue.", "citations": "", "retrieved_chunks": "", "latency_s": 8.9647}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "ds-notes", "pdf_name": "DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "pages": 17, "question_id": "ds_q9", "question": "Define a queue and explain FIFO.", "expected": "- Linear data structure\n- Follows FIFO principle\n- Insertion at rear, deletion at front", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "A Queue is a linear data structure that follows the First In, First Out (FIFO) principle. This means that the first element inserted into the queue will be the first one to be removed. Real-world examples include ticket lines, print queues, and CPU task scheduling. Operations like `enqueue` (inserting an element at the rear), `dequeue` (removing and returning an element from the front), `peek`/`top` (returning the top element without removing it), and `isEmpty` (checking if the queue is empty) all have a time complexity of O(1).", "citations": "p8:c1|p5:c0|p9:c0|p4:c0|p12:c1", "retrieved_chunks": "p8: inorder(node) {      if (node == NULL) return;      inorder(node->left);      visit(node);      inorder(node->right);  }  Inorder: 20 10 30  preorder(node) {      if (node == NULL) return;      visit(node);      preorder(node->left);      preorder(node->right);  }  Preorder: 10 20 30  DATA STRUCTURE GATE फर्रे  Page No:- 07 | p5: Operation Description Time  Complexity  enqueue(x) Insert  element x at  the rear  O (1) (array  or LL)  dequeue() Remove  and return  element  from front  O (1)  • Type • Description • Simple Queue • Basic FIFO queue (insertion at rear, deletion at front) • Circular Queue • Last position connects back to first (solves overflow in array) • Deque (Double- Ended Queue) • Insertion/deletion possible from both ends • Priority Queue • Elements served based on prior", "latency_s": 65.8622}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "ds-notes", "pdf_name": "DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "pages": 17, "question_id": "ds_q10", "question": "What is the drawback of a simple linear queue?", "expected": "- False overflow occurs\n- Unused memory cannot be reused\n- Rear reaches end of array", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "The main drawback of a simple linear queue is that it can become inefficient when items need to be accessed or removed from positions other than the end of the queue, as this would require shifting all elements.", "citations": "", "retrieved_chunks": "", "latency_s": 7.1346}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "ds-notes", "pdf_name": "DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "pages": 17, "question_id": "ds_q10", "question": "What is the drawback of a simple linear queue?", "expected": "- False overflow occurs\n- Unused memory cannot be reused\n- Rear reaches end of array", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "The drawback of a simple/linear queue using an array, as described in the context, is that after performing several enqueue and dequeue operations:\n\n- The front moves ahead.\n- However, the rear reaches the end of the array.\n- Even though free space exists at the beginning of the array, it cannot be utilized due to the fixed structure of the array.\nThis leads to a false overflow situation where the queue appears full even when there is unused capacity.", "citations": "p5:c0|p4:c0|p10:c1|p15:c0|p9:c0", "retrieved_chunks": "p5: Operation Description Time  Complexity  enqueue(x) Insert  element x at  the rear  O (1) (array  or LL)  dequeue() Remove  and return  element  from front  O (1)  • Type • Description • Simple Queue • Basic FIFO queue (insertion at rear, deletion at front) • Circular Queue • Last position connects back to first (solves overflow in array) • Deque (Double- Ended Queue) • Insertion/deletion possible from both ends • Priority Queue • Elements served based on priority, not position In a simple/linear queue using array, after a few  enqueue and dequeue operations:  • The front moves ahead • But rear reaches the end of array • Even though free space exists at the beginning, we can't use it This leads to a false overflow.   Solution:  In a circular queue, we connect the rear back to  front, fo", "latency_s": 63.3046}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "ds-notes", "pdf_name": "DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "pages": 17, "question_id": "ds_q11", "question": "How does a circular queue overcome false overflow?", "expected": "- Rear connects back to front\n- Uses modulo arithmetic\n- Efficient memory utilization", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "A circular queue overcomes false overflow by using a combination of front and rear pointers that wrap around when they reach the end of the array. This allows the queue to reuse spaces once an element is dequeued, effectively making the queue appear larger than its physical size.", "citations": "", "retrieved_chunks": "", "latency_s": 8.7331}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "ds-notes", "pdf_name": "DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "pages": 17, "question_id": "ds_q11", "question": "How does a circular queue overcome false overflow?", "expected": "- Rear connects back to front\n- Uses modulo arithmetic\n- Efficient memory utilization", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "A circular queue overcomes false overflow by connecting the rear back to the front, forming a circle. This allows the queue to use free space at the beginning even when the rear has reached the end of the array, thus preventing what would otherwise be a false overflow situation.", "citations": "p5:c0|p9:c0|p10:c1|p15:c0|p4:c0", "retrieved_chunks": "p5: Operation Description Time  Complexity  enqueue(x) Insert  element x at  the rear  O (1) (array  or LL)  dequeue() Remove  and return  element  from front  O (1)  • Type • Description • Simple Queue • Basic FIFO queue (insertion at rear, deletion at front) • Circular Queue • Last position connects back to first (solves overflow in array) • Deque (Double- Ended Queue) • Insertion/deletion possible from both ends • Priority Queue • Elements served based on priority, not position In a simple/linear queue using array, after a few  enqueue and dequeue operations:  • The front moves ahead • But rear reaches the end of array • Even though free space exists at the beginning, we can't use it This leads to a false overflow.   Solution:  In a circular queue, we connect the rear back to  front, fo", "latency_s": 58.4362}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "ds-notes", "pdf_name": "DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "pages": 17, "question_id": "ds_q12", "question": "What is a priority queue?", "expected": "- Elements served based on priority\n- Higher priority served first\n- Not strictly FIFO", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "A priority queue is a data structure that stores elements along with their associated priorities. Elements with higher priority are dequeued or retrieved before elements with lower priority. Common operations include adding an element and removing the highest-priority element.", "citations": "", "retrieved_chunks": "", "latency_s": 7.7179}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "ds-notes", "pdf_name": "DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "pages": 17, "question_id": "ds_q12", "question": "What is a priority queue?", "expected": "- Elements served based on priority\n- Higher priority served first\n- Not strictly FIFO", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "A priority queue is a type of abstract data structure in which each element is associated with a priority, and elements are served based on their priority, not just insertion order.", "citations": "p5:c0|p8:c1|p9:c0|p10:c1|p4:c0", "retrieved_chunks": "p5: Operation Description Time  Complexity  enqueue(x) Insert  element x at  the rear  O (1) (array  or LL)  dequeue() Remove  and return  element  from front  O (1)  • Type • Description • Simple Queue • Basic FIFO queue (insertion at rear, deletion at front) • Circular Queue • Last position connects back to first (solves overflow in array) • Deque (Double- Ended Queue) • Insertion/deletion possible from both ends • Priority Queue • Elements served based on priority, not position In a simple/linear queue using array, after a few  enqueue and dequeue operations:  • The front moves ahead • But rear reaches the end of array • Even though free space exists at the beginning, we can't use it This leads to a false overflow.   Solution:  In a circular queue, we connect the rear back to  front, fo", "latency_s": 52.599}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "ds-notes", "pdf_name": "DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "pages": 17, "question_id": "ds_q13", "question": "Define a binary tree.", "expected": "- Hierarchical data structure\n- Each node has at most two children\n- Has root and subtrees", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "A binary tree is a tree data structure in which each node has at most two children, referred to as the left child and the right child.", "citations": "", "retrieved_chunks": "", "latency_s": 5.6117}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "ds-notes", "pdf_name": "DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "pages": 17, "question_id": "ds_q13", "question": "Define a binary tree.", "expected": "- Hierarchical data structure\n- Each node has at most two children\n- Has root and subtrees", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "A binary tree is a non-linear, hierarchical data structure consisting of nodes, with a single root node and zero or more child nodes, forming a parent-child relationship. Each node in a binary tree can have at most two children, referred to as the left child and the right child. The root node sits at the top of the hierarchy, while leaf nodes (nodes without any children) are at the bottom. Nodes with children are called internal nodes or branch nodes.", "citations": "p7:c0|p6:c1|p5:c1|p6:c0|p8:c0", "retrieved_chunks": "p7: Complete Binary tree  This is the binary tree which is filled at second last  level, and the insertion happens from the left to right.  For complete binary tree   • Minimum number of nodes is 2 ℎ • Maximum number of nodes is = 2ℎ+1 −1 Binary Search Tree  Left < root < right  Every structure of the n node has unique binary search  tree.   i.e. if we have 3 keys, then then we have the 5 structures This are the structure with five nodes. Now we have  the only 1 binary search tree with every structure.   So total binary search tree with n keys =  2𝑛𝑛𝐶𝐶𝑛𝑛 𝑛𝑛+1  ! Binary search tree is not the complete binary tree. Insertion in a BST   Average case, O(logn)    Worst case, O(n)       This is not the CBT, because it doesn’t follow  the properties.  Three Cases of Deletion:  1. Case 1: Node has", "latency_s": 81.2663}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "ds-notes", "pdf_name": "DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "pages": 17, "question_id": "ds_q14", "question": "State the property of a Binary Search Tree.", "expected": "- Left subtree < root\n- Right subtree > root\n- Inorder traversal gives sorted order", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "In a Binary Search Tree (BST), for every node, the value of all nodes in its left subtree is less than the node's value, and the value of all nodes in its right subtree is greater than the node's value.", "citations": "", "retrieved_chunks": "", "latency_s": 8.9434}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "ds-notes", "pdf_name": "DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "pages": 17, "question_id": "ds_q14", "question": "State the property of a Binary Search Tree.", "expected": "- Left subtree < root\n- Right subtree > root\n- Inorder traversal gives sorted order", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "The provided context does not explicitly state the property of a Binary Search Tree. The context includes information about inorder, preorder, and postorder traversal sequences, as well as definitions for heaps and tridiagonal matrices, but it does not mention any specific properties of a Binary Search Tree. Therefore, based on the given information, I cannot provide an answer to the question \"State the property of a Binary Search Tree.\"", "citations": "p8:c1|p9:c0|p6:c1|p15:c0|p3:c0", "retrieved_chunks": "p8: inorder(node) {      if (node == NULL) return;      inorder(node->left);      visit(node);      inorder(node->right);  }  Inorder: 20 10 30  preorder(node) {      if (node == NULL) return;      visit(node);      preorder(node->left);      preorder(node->right);  }  Preorder: 10 20 30  DATA STRUCTURE GATE फर्रे  Page No:- 07 | p9: Postorder  Left Subtree → Right Subtree → Node  Heap  A Heap is a special Complete Binary Tree where  every level is completely filled except possibly the last  level, and nodes are as far left as possible.   Min Heap  The value of each node is less than or equal to its  children.  |𝒂𝒂𝒌𝒌| < | left tree, right tree|  Root = Minimum element  postorder(node) {      if (node == NULL) return;      postorder(node->left);      postorder(node->right);      visit(node)", "latency_s": 53.4383}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "ds-notes", "pdf_name": "DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "pages": 17, "question_id": "ds_q15", "question": "Explain the three cases of deletion in a BST.", "expected": "- Leaf node deletion\n- Node with one child\n- Node with two children using inorder successor/predecessor", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "In a Binary Search Tree (BST), deletion can be handled in three main cases:\n\n1. **Node with No Children**: Simply remove the node.\n2. **Node with One Child**: Replace the node's position with its child.\n3. **Node with Two Children**: \n   - Find the inorder successor (smallest in the right subtree).\n   - Replace the node's value with the successor's value.\n   - Delete the inorder successor node.", "citations": "", "retrieved_chunks": "", "latency_s": 13.6965}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "ds-notes", "pdf_name": "DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "pages": 17, "question_id": "ds_q15", "question": "Explain the three cases of deletion in a BST.", "expected": "- Leaf node deletion\n- Node with one child\n- Node with two children using inorder successor/predecessor", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "The provided context does not contain information about the three cases of deletion in a BST. The context discusses inorder successor/predecessor for node replacement, time complexity, and other data structures like tridiagonal matrices, linked lists, stacks, heaps, and hashing. Therefore, I cannot answer the question based on the given context.", "citations": "p7:c1|p3:c0|p9:c0|p14:c0|p15:c0", "retrieved_chunks": "p7: o Replace the node with its:  Inorder Successor (smallest in right subtree) or  Inorder Predecessor (largest in left subtree) o Then delete the successor/predecessor recursively. Time Complexity:  • Best/Average Case: O(logn)— for balanced BST • Worst Case: O(n) — for skewed BST DATA STRUCTURE GATE फर्रे  Page No:- 06 | p3: Tridiagonal matrix  A tridiagonal matrix is a square matrix where non- zero elements exist only on the main diagonal, just  above it, and just below it.  A[i][j] ≠ 0 only if i == j, i == j+1, or i == j–1  Else, A[i][j] = 0  Sum of all the element is 3n-2.  A linked list is a linear data structure where elements  (called nodes) are stored in non-contiguous memory  locations and connected using pointers.  Each node contains:  • Data • Pointer (next) to the next node", "latency_s": 56.7038}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "cn-notes", "pdf_name": "Computer-Network--_compressed.pdf", "pages": 42, "question_id": "cn_q1", "question": "What is the purpose of an IP address?", "expected": "- Uniquely identifies a device\n- Identifies network and host\n- Used for routing packets", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "The purpose of an IP address is to uniquely identify devices on a network and enable communication between them.", "citations": "", "retrieved_chunks": "", "latency_s": 4.5858}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "cn-notes", "pdf_name": "Computer-Network--_compressed.pdf", "pages": 42, "question_id": "cn_q1", "question": "What is the purpose of an IP address?", "expected": "- Uniquely identifies a device\n- Identifies network and host\n- Used for routing packets", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "The context provided does not explicitly state the purpose of an IP address. The given information discusses private IP addresses, broadcast communication, and protocols like SMTP and POP3, but it does not directly explain the general purpose of IP addresses. Therefore, based on the given context, I cannot provide a specific answer to what the purpose of an IP address is.", "citations": "p26:c1|p4:c0|p2:c1|p23:c1|p29:c1", "retrieved_chunks": "p26: physical address to send data. 2. ICMP Messages (Internet Control Message Protocol) ICMP messages are of two types: 1. Error-reporting or Feedback Messages These are sent when there is a problem in the network. There are 5 types:  Error Message  Type    Meaning  Destination  Unreachable  The packet cannot reach  the final destination.  Source Quench Tells the sender to slow  down sending packets.  Time Exceeded Packet took too long and  got dropped.  Parameter  Problems  There’s something wrong in  the packet’s header (info).  Redirection Suggests a better route for  the packet.  2. Query or Request and Reply Messages These are used for asking questions or sending requests and getting replies. COMPUETR NETWORK GATE फर्रे  Page No:- 23 | p4: Private IP addresses:  ● 10.0.0.0 to 10.255.", "latency_s": 50.3053}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "cn-notes", "pdf_name": "Computer-Network--_compressed.pdf", "pages": 42, "question_id": "cn_q2", "question": "Differentiate between network ID and host ID.", "expected": "- Network ID identifies the network\n- Host ID identifies device within network\n- Same NID for all devices in network", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Network ID identifies the network part of an IP address, while Host ID identifies the specific device on that network.", "citations": "", "retrieved_chunks": "", "latency_s": 4.7938}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "cn-notes", "pdf_name": "Computer-Network--_compressed.pdf", "pages": 42, "question_id": "cn_q2", "question": "Differentiate between network ID and host ID.", "expected": "- Network ID identifies the network\n- Host ID identifies device within network\n- Same NID for all devices in network", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "The provided context does not contain any information about network ID and host ID differentiation. Therefore, I cannot answer the question based on the given context.", "citations": "p27:c0|p25:c1|p26:c1|p25:c0|p39:c1", "retrieved_chunks": "p27: There are 4 types:  Query Message  Type  Meaning  Echo Request and  Reply  Used for testing if the  other device is active.  (Ping uses this)  Timestamp  Request and Reply  Used to check the time  between two devices.  Address-mask  Request and Reply  Asks for the subnet mask  information.  Router Solicitation  and  Advertisement  Used by devices to find  nearby routers.  APPLICATION LAYER PROTOCOL   The Application Layer is the topmost layer in the OSI  and TCP/IP models. It directly interacts with the end  user and provides network services to applications  like web browsers, email clients, etc.  There are some Application Layer Protocols  1. HTTP 2. FTP 3. SMTP 4. POP3 5. IMAP 6. DNS HTTP Protocols-  1. HTTP is used to access data on the World Wide Web (www). 2. It is a client-serv", "latency_s": 55.6702}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "cn-notes", "pdf_name": "Computer-Network--_compressed.pdf", "pages": 42, "question_id": "cn_q3", "question": "Explain classful IP addressing.", "expected": "- IP divided into fixed classes\n- Classes based on first bits\n- Includes Class A to E", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Classful IP addressing divides IP addresses into five classes (A, B, C, D, and E) based on the first octet, determining the default subnet mask and maximum number of networks and hosts. Classes A, B, and C have fixed bits for network identification, while classes D and E are used for multicast and research purposes, respectively.", "citations": "", "retrieved_chunks": "", "latency_s": 10.9634}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "cn-notes", "pdf_name": "Computer-Network--_compressed.pdf", "pages": 42, "question_id": "cn_q3", "question": "Explain classful IP addressing.", "expected": "- IP divided into fixed classes\n- Classes based on first bits\n- Includes Class A to E", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "The provided context does not contain information about classful IP addressing. Therefore, I cannot answer the question based on the given context.", "citations": "p26:c1|p4:c0|p37:c1|p23:c1|p39:c1", "retrieved_chunks": "p26: physical address to send data. 2. ICMP Messages (Internet Control Message Protocol) ICMP messages are of two types: 1. Error-reporting or Feedback Messages These are sent when there is a problem in the network. There are 5 types:  Error Message  Type    Meaning  Destination  Unreachable  The packet cannot reach  the final destination.  Source Quench Tells the sender to slow  down sending packets.  Time Exceeded Packet took too long and  got dropped.  Parameter  Problems  There’s something wrong in  the packet’s header (info).  Redirection Suggests a better route for  the packet.  2. Query or Request and Reply Messages These are used for asking questions or sending requests and getting replies. COMPUETR NETWORK GATE फर्रे  Page No:- 23 | p4: Private IP addresses:  ● 10.0.0.0 to 10.255.", "latency_s": 33.1754}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "cn-notes", "pdf_name": "Computer-Network--_compressed.pdf", "pages": 42, "question_id": "cn_q4", "question": "List the IP address ranges for Class A, B, and C.", "expected": "- Class A: 1–126\n- Class B: 128–191\n- Class C: 192–223", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Class A: 1.0.0.0 to 127.255.255.255\nClass B: 128.0.0.0 to 191.255.255.255\nClass C: 192.0.0.0 to 223.255.255.255", "citations": "", "retrieved_chunks": "", "latency_s": 13.6434}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "cn-notes", "pdf_name": "Computer-Network--_compressed.pdf", "pages": 42, "question_id": "cn_q4", "question": "List the IP address ranges for Class A, B, and C.", "expected": "- Class A: 1–126\n- Class B: 128–191\n- Class C: 192–223", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "The provided context does not contain information about the IP address ranges for Class A, B, and C. The context only lists private IP address ranges and does not differentiate between Class A, B, and C public IP addresses. Therefore, I cannot provide an answer based on the given information.", "citations": "p4:c0|p2:c1|p26:c1|p23:c1|p5:c1", "retrieved_chunks": "p4: Private IP addresses:  ● 10.0.0.0 to 10.255.255.255 ● 172.16.0.0 to 172.31.255.255 ● 192.168.0.0 to 192.168.255.255 COMPUETR NETWORK GATE फर्रे  Page No:- 03 | p2: Broadcast Communication:  ● Limited Broadcast → Transmitting data 1 to all in same n/w ● Directed Broadcast → Transmitting data 1 to all in different n/w ● Limited Broadcast address =255.255.255.255 ● Directed Broadcast address (DBA) = All HID should be 1 ● Can’t use as source IP ● Always used as destination address COMPUETR NETWORK GATE फर्रे  Page No:- 01 | p26: physical address to send data. 2. ICMP Messages (Internet Control Message Protocol) ICMP messages are of two types: 1. Error-reporting or Feedback Messages These are sent when there is a problem in the network. There are 5 types:  Error Message  Type    Meaning  De", "latency_s": 44.8682}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "cn-notes", "pdf_name": "Computer-Network--_compressed.pdf", "pages": 42, "question_id": "cn_q5", "question": "What is a limited broadcast address?", "expected": "- Used to reach all hosts in network\n- Address is 255.255.255.255\n- Used only as destination address", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "A limited broadcast address is an IP address used in IPv4 to send a message to all devices on the local network segment, but not beyond it. It's typically represented as 255.255.255.255.", "citations": "", "retrieved_chunks": "", "latency_s": 8.5799}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "cn-notes", "pdf_name": "Computer-Network--_compressed.pdf", "pages": 42, "question_id": "cn_q5", "question": "What is a limited broadcast address?", "expected": "- Used to reach all hosts in network\n- Address is 255.255.255.255\n- Used only as destination address", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "A limited broadcast address is 255.255.255.255. It is used for transmitting data to all devices in the same network.", "citations": "p26:c1|p4:c0|p14:c1|p23:c1|p2:c1", "retrieved_chunks": "p26: physical address to send data. 2. ICMP Messages (Internet Control Message Protocol) ICMP messages are of two types: 1. Error-reporting or Feedback Messages These are sent when there is a problem in the network. There are 5 types:  Error Message  Type    Meaning  Destination  Unreachable  The packet cannot reach  the final destination.  Source Quench Tells the sender to slow  down sending packets.  Time Exceeded Packet took too long and  got dropped.  Parameter  Problems  There’s something wrong in  the packet’s header (info).  Redirection Suggests a better route for  the packet.  2. Query or Request and Reply Messages These are used for asking questions or sending requests and getting replies. COMPUETR NETWORK GATE फर्रे  Page No:- 23 | p4: Private IP addresses:  ● 10.0.0.0 to 10.255.", "latency_s": 37.7093}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "cn-notes", "pdf_name": "Computer-Network--_compressed.pdf", "pages": 42, "question_id": "cn_q6", "question": "Define subnetting.", "expected": "- Dividing a network into sub-networks\n- Borrow bits from host ID\n- Improves address utilization", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Subnetting is the process of dividing a large network into smaller, more manageable segments called subnets. This helps in managing IP addresses efficiently and improving network performance and security.", "citations": "", "retrieved_chunks": "", "latency_s": 6.2528}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "cn-notes", "pdf_name": "Computer-Network--_compressed.pdf", "pages": 42, "question_id": "cn_q6", "question": "Define subnetting.", "expected": "- Dividing a network into sub-networks\n- Borrow bits from host ID\n- Improves address utilization", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Subnetting is borrowing bits from the Host ID (HID) to create subnetworks. The process helps in identifying which portion of an IP address is the Network ID and which portion is the Host ID. Key rules for subnetting include:\n\n- All IP addresses in the block must be contiguous.\n- Block size must be a power of 2.\n- The first IP address of the block must be divisible by the size of the block.\n\nThe default subnet masks for different classes are also provided: Class A (255.0.0.0), Class B (255.255.0.0), and Class C (255.255.255.0).", "citations": "p3:c1|p26:c1|p3:c0|p9:c1|p23:c1", "retrieved_chunks": "p3: by size of block Supernetting  ● The process of combining two or more networks  to get a single network is called supernetting. ● (Subnet mask borrowed from net ID) Advantages of Supernetting:  ● Reduces routing table entries ● Router will take less time for processing packets ● Improves flexibility of IP address allotment Rules of Supernetting:  1. Networks ID must be contiguous 2. Size of the Network must be same and networks must be multiple of 2 3. First Netwok ID must be divisible by size of supernet 4. Block should be of equal size & belong to same class COMPUETR NETWORK GATE फर्रे  Page No:- 02 | p26: physical address to send data. 2. ICMP Messages (Internet Control Message Protocol) ICMP messages are of two types: 1. Error-reporting or Feedback Messages These are sent when ther", "latency_s": 73.4259}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "cn-notes", "pdf_name": "Computer-Network--_compressed.pdf", "pages": 42, "question_id": "cn_q7", "question": "What is CIDR and why is it used?", "expected": "- Classless addressing method\n- Uses prefix length /n\n- Reduces IP wastage", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "CIDR stands for Classless Interdomain Routing. It's used to manage IP address blocks more efficiently by allowing variable-length subnet masks. This improves routing efficiency and conserves IPv4 addresses.", "citations": "", "retrieved_chunks": "", "latency_s": 6.9334}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "cn-notes", "pdf_name": "Computer-Network--_compressed.pdf", "pages": 42, "question_id": "cn_q7", "question": "What is CIDR and why is it used?", "expected": "- Classless addressing method\n- Uses prefix length /n\n- Reduces IP wastage", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "The provided context does not contain any information about CIDR (Classless Interdomain Routing). Therefore, I cannot answer the question based on the given context.", "citations": "p26:c1|p23:c1|p29:c1|p37:c1|p9:c1", "retrieved_chunks": "p26: physical address to send data. 2. ICMP Messages (Internet Control Message Protocol) ICMP messages are of two types: 1. Error-reporting or Feedback Messages These are sent when there is a problem in the network. There are 5 types:  Error Message  Type    Meaning  Destination  Unreachable  The packet cannot reach  the final destination.  Source Quench Tells the sender to slow  down sending packets.  Time Exceeded Packet took too long and  got dropped.  Parameter  Problems  There’s something wrong in  the packet’s header (info).  Redirection Suggests a better route for  the packet.  2. Query or Request and Reply Messages These are used for asking questions or sending requests and getting replies. COMPUETR NETWORK GATE फर्रे  Page No:- 23 | p23: start. Start Frame Delimiter (SFD): ● It is", "latency_s": 47.9888}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "cn-notes", "pdf_name": "Computer-Network--_compressed.pdf", "pages": 42, "question_id": "cn_q8", "question": "Explain the concept of supernetting.", "expected": "- Combines multiple networks\n- Reduces routing table size\n- Borrow bits from network ID", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Supernetting is an IP addressing technique that combines multiple smaller networks into a single larger network to reduce the number of routing entries in a network. It involves using a supernetwork or supernet, which is created by borrowing bits from the host portion of an IP address to form a larger network. This reduces the need for subnets and simplifies route summarization in large networks.", "citations": "", "retrieved_chunks": "", "latency_s": 11.6187}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "cn-notes", "pdf_name": "Computer-Network--_compressed.pdf", "pages": 42, "question_id": "cn_q8", "question": "Explain the concept of supernetting.", "expected": "- Combines multiple networks\n- Reduces routing table size\n- Borrow bits from network ID", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Supernetting is the process of combining two or more networks to get a single network. This technique reduces routing table entries and allows routers to process packets faster, thereby improving overall network efficiency. For supernetting to work, certain rules must be followed:\n1. Network IDs must be contiguous.\n2. The size of the networks must be the same and should be multiples of 2.\n3. The first network ID must be divisible by the size of the supernet.\n4. Blocks should be of equal size and belong to the same class.\n\nThese rules ensure that supernetting is implemented correctly, maintaining the integrity and functionality of the network structure.", "citations": "p3:c1|p3:c0|p30:c1|p26:c0|p18:c1", "retrieved_chunks": "p3: by size of block Supernetting  ● The process of combining two or more networks  to get a single network is called supernetting. ● (Subnet mask borrowed from net ID) Advantages of Supernetting:  ● Reduces routing table entries ● Router will take less time for processing packets ● Improves flexibility of IP address allotment Rules of Supernetting:  1. Networks ID must be contiguous 2. Size of the Network must be same and networks must be multiple of 2 3. First Netwok ID must be divisible by size of supernet 4. Block should be of equal size & belong to same class COMPUETR NETWORK GATE फर्रे  Page No:- 02 | p3: Special Cases:  NID HID  valid all 0’s → N/w  id of entire  n/w  valid  All 1’s →  Directed  broadcast  address  (DBA)  All 1’s all 1’s →  Limited  broadcast  address  (LBA)  7. Sub", "latency_s": 80.627}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "cn-notes", "pdf_name": "Computer-Network--_compressed.pdf", "pages": 42, "question_id": "cn_q9", "question": "What is error detection?", "expected": "- Detects errors in transmitted data\n- Requests retransmission if error found\n- Does not correct errors", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Error detection is a method used to identify whether data transmitted or stored has been altered or corrupted. It involves adding extra bits to the original data to create a code that can be checked at a later stage for integrity.", "citations": "", "retrieved_chunks": "", "latency_s": 7.29}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "cn-notes", "pdf_name": "Computer-Network--_compressed.pdf", "pages": 42, "question_id": "cn_q9", "question": "What is error detection?", "expected": "- Detects errors in transmitted data\n- Requests retransmission if error found\n- Does not correct errors", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Error detection involves identifying when an error has occurred in the transmission or storage of data. According to the context provided, methods for error detection include simple parity, 2D parity, checksums, and CRC (Cyclic Redundancy Check). The document states that if an error is found during error detection, the typical action is to discard the data and request retransmission.", "citations": "p8:c0|p24:c0|p5:c0|p9:c1|p6:c0", "retrieved_chunks": "p8: 4. Hamming Code (Error Correction) ● Hamming Code is used for error correction. ● It can correct single-bit errors. ● It can detect up to two-bit errors. ● m = message bits ● r = redundant (check/parity/extra) bits ● n=m+r total codeword length According to the Hamming Code condition, the  minimum number of redundant bits required is:  2^r≥m+r +1  Here, r represents the lower limit of the  redundant bits needed.  ●   Key Points to Remember:  ● CRC → remainder after polynomial division. ● Checksum → 1’s complement sum method. ● Hamming Code → error detection + correction (1-bit errors, up to 2-bit detection). COMPUETR NETWORK GATE फर्रे  Page No:- 07 | p24: ● It is a 2B field which specifies the length of data field. Data: ● It is a variable-length field which contains the actual data. ", "latency_s": 69.3624}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "cn-notes", "pdf_name": "Computer-Network--_compressed.pdf", "pages": 42, "question_id": "cn_q10", "question": "Define Hamming distance.", "expected": "- Number of differing bit positions\n- Measured using XOR operation\n- Used in error detection and correction", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Hamming distance is the number of positions at which the corresponding symbols are different in two strings of equal length.", "citations": "", "retrieved_chunks": "", "latency_s": 4.6339}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "cn-notes", "pdf_name": "Computer-Network--_compressed.pdf", "pages": 42, "question_id": "cn_q10", "question": "Define Hamming distance.", "expected": "- Number of differing bit positions\n- Measured using XOR operation\n- Used in error detection and correction", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Hamming distance can be defined as the number of positions at which the corresponding bits of two codewords are different. It can be found by applying the XOR operation on two codewords and counting the number of 1’s in the result. In a set of codewords, the minimum Hamming distance is determined by taking the smallest Hamming distance between all possible pairs of codewords.", "citations": "p5:c1|p4:c0|p26:c1|p2:c1|p34:c0", "retrieved_chunks": "p5: 3. d(101, 110) = 2 hamming distance ● Hamming distance can be found by applying XOR operation ( ⊕) on  two codewords and counting the number of 1’s in the result. Minimum Hamming Distance:  ● In a set of codewords, the minimum Hamming distance between all possible pairs of codewords is taken. Example:   Valid codewords:  ● a: 010 ● b: 101 ● c: 110 ● d: 001 COMPUETR NETWORK GATE फर्रे  Page No:- 04 | p4: Private IP addresses:  ● 10.0.0.0 to 10.255.255.255 ● 172.16.0.0 to 172.31.255.255 ● 192.168.0.0 to 192.168.255.255 COMPUETR NETWORK GATE फर्रे  Page No:- 03 | p26: physical address to send data. 2. ICMP Messages (Internet Control Message Protocol) ICMP messages are of two types: 1. Error-reporting or Feedback Messages These are sent when there is a problem in the network. There are 5 t", "latency_s": 51.4211}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "cn-notes", "pdf_name": "Computer-Network--_compressed.pdf", "pages": 42, "question_id": "cn_q11", "question": "What is CRC and why is it reliable?", "expected": "- Cyclic Redundancy Check\n- Uses polynomial division\n- Detects burst errors efficiently", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "CRC stands for Cyclic Redundancy Check. It's a method of detecting accidental changes or corruption in digital data. CRC is reliable because it uses polynomial division to generate a checksum, which effectively catches most types of errors that might occur during data transmission or storage.", "citations": "", "retrieved_chunks": "", "latency_s": 8.6745}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "cn-notes", "pdf_name": "Computer-Network--_compressed.pdf", "pages": 42, "question_id": "cn_q11", "question": "What is CRC and why is it reliable?", "expected": "- Cyclic Redundancy Check\n- Uses polynomial division\n- Detects burst errors efficiently", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "The context provided does not contain any specific information about CRC (Cyclic Redundancy Check) or its reliability. Therefore, based on the given context, I cannot provide an answer to the question \"What is CRC and why is it reliable?\" The context mentions error control but does not detail CRC specifically.", "citations": "p39:c1|p26:c1|p23:c1|p40:c0|p9:c1", "retrieved_chunks": "p39: ● Handles fragmentation and reassembly of packets. Transport Layer  ● Provides end-to-end communication between applications on hosts. ● Ensures reliable or unreliable data delivery depending on protocol. ● Main protocols: ○ TCP (Transmission Control Protocol): reliable, connection-oriented, error- checked. COMPUETR NETWORK GATE फर्रे  Page No:- 35 | p26: physical address to send data. 2. ICMP Messages (Internet Control Message Protocol) ICMP messages are of two types: 1. Error-reporting or Feedback Messages These are sent when there is a problem in the network. There are 5 types:  Error Message  Type    Meaning  Destination  Unreachable  The packet cannot reach  the final destination.  Source Quench Tells the sender to slow  down sending packets.  Time Exceeded Packet took too long a", "latency_s": 52.092}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "cn-notes", "pdf_name": "Computer-Network--_compressed.pdf", "pages": 42, "question_id": "cn_q12", "question": "Differentiate between error detection and correction.", "expected": "- Detection finds presence of error\n- Correction identifies and fixes error\n- Correction avoids retransmission", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Error detection involves identifying when an error has occurred in data transmission or storage without necessarily correcting it. Error correction not only detects errors but also fixes them by adding redundant data that allows the original information to be reconstructed.", "citations": "", "retrieved_chunks": "", "latency_s": 7.3429}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "cn-notes", "pdf_name": "Computer-Network--_compressed.pdf", "pages": 42, "question_id": "cn_q12", "question": "Differentiate between error detection and correction.", "expected": "- Detection finds presence of error\n- Correction identifies and fixes error\n- Correction avoids retransmission", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Error detection involves identifying that an error has occurred in the transmitted data, but it does not correct the errors. Common methods for error detection include simple parity, 2D parity, checksums, and CRC (Cyclic Redundancy Check).\n\nOn the other hand, error correction not only detects the presence of errors but also corrects them without needing to request retransmission of the data. Hamming code is an example of a method that can both detect and correct single-bit errors, as well as detect up to two-bit errors.\n\nIn summary:\n- **Error Detection**: Identifies if there are any errors in the transmitted data.\n- **Error Correction**: Detects errors and also fixes them without needing retransmission.", "citations": "p8:c0|p5:c0|p9:c1|p24:c0|p6:c0", "retrieved_chunks": "p8: 4. Hamming Code (Error Correction) ● Hamming Code is used for error correction. ● It can correct single-bit errors. ● It can detect up to two-bit errors. ● m = message bits ● r = redundant (check/parity/extra) bits ● n=m+r total codeword length According to the Hamming Code condition, the  minimum number of redundant bits required is:  2^r≥m+r +1  Here, r represents the lower limit of the  redundant bits needed.  ●   Key Points to Remember:  ● CRC → remainder after polynomial division. ● Checksum → 1’s complement sum method. ● Hamming Code → error detection + correction (1-bit errors, up to 2-bit detection). COMPUETR NETWORK GATE फर्रे  Page No:- 07 | p5: Error Control  ● Number of corrupted bits = Data rate × Noise duration ● Burst error is more likely to occur than single bit error. ", "latency_s": 80.4385}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "cn-notes", "pdf_name": "Computer-Network--_compressed.pdf", "pages": 42, "question_id": "cn_q13", "question": "Define transmission delay.", "expected": "- Time to push packet onto link\n- Formula: Td = L / R\n- Depends on packet size and rate", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Transmission delay is the time it takes for data to travel from the sender's device to the receiver's device, considering only the transmission process and not including propagation delays or other factors.", "citations": "", "retrieved_chunks": "", "latency_s": 6.4423}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "cn-notes", "pdf_name": "Computer-Network--_compressed.pdf", "pages": 42, "question_id": "cn_q13", "question": "Define transmission delay.", "expected": "- Time to push packet onto link\n- Formula: Td = L / R\n- Depends on packet size and rate", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Transmission Delay (Td) is the amount of time taken to transfer a packet onto the outgoing link. It can be calculated using the formula:\n\n\\[ Td = \\frac{L}{R} \\]\n\nwhere:\n- \\( L \\) is the length of the packet,\n- \\( R \\) is the transmission rate.", "citations": "p9:c1|p9:c0|p22:c1|p26:c1|p35:c1", "retrieved_chunks": "p9: the header, perform an error detection, etc. Total Time / Round Trip Time (RTT):  ● It is the additional time between a request for data and the display of that data.  RTT=Td(frame)+2⋅Pd+Qd+Prd+Td(ack)  Efficiency / Line Utilization / Link  Utilization / Sender Utilization:  Efficiency=Useful Time/Total Time  Throughput / Effective Bandwidth /  Bandwidth Utilization:  ● Maximum data rate possible. Throughput=Efficiency×Bandwidth  Throughpu   t=  L /  Td(frame)+2⋅Pd+Qd+Prd+Td(ack)  Capacity of Link / Wire / Channel:  ● Max number of bits available on a link at any time. Capacity of Link=B×Pd  Stop and Wait Protocol:  ● Can deal with frame lost, ACK lost, ACK delayed.  COMPUETR NETWORK GATE फर्रे  Page No:- 08 | p9: Flow Control  Bandwidth:  ● Bandwidth refers to maximum rate of data tra", "latency_s": 58.7829}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "cn-notes", "pdf_name": "Computer-Network--_compressed.pdf", "pages": 42, "question_id": "cn_q14", "question": "Explain Stop-and-Wait protocol.", "expected": "- Sender sends one frame at a time\n- Waits for ACK before next frame\n- Simple but low efficiency", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Stop-and-Wait protocol is a simple flow control mechanism used in computer networking. It works as follows:\n\n1. Sender sends one data packet.\n2. Receiver acknowledges receipt of the packet.\n3. Sender waits for acknowledgment before sending next packet.\n\nThis ensures reliable data transmission by requiring an explicit acknowledgment for each sent packet.", "citations": "", "retrieved_chunks": "", "latency_s": 10.2669}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "cn-notes", "pdf_name": "Computer-Network--_compressed.pdf", "pages": 42, "question_id": "cn_q14", "question": "Explain Stop-and-Wait protocol.", "expected": "- Sender sends one frame at a time\n- Waits for ACK before next frame\n- Simple but low efficiency", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "The provided context does not contain any information about the Stop-and-Wait protocol. Therefore, I cannot answer the question based on the given context.", "citations": "p39:c1|p28:c1|p26:c1|p29:c1|p40:c1", "retrieved_chunks": "p39: ● Handles fragmentation and reassembly of packets. Transport Layer  ● Provides end-to-end communication between applications on hosts. ● Ensures reliable or unreliable data delivery depending on protocol. ● Main protocols: ○ TCP (Transmission Control Protocol): reliable, connection-oriented, error- checked. COMPUETR NETWORK GATE फर्रे  Page No:- 35 | p28: ○ They use separate connections. 10. Some protocols (like FTP) send requests and data on different connections, so they are called Out-of-Band. 11. Others (like HTTP & SMTP) use the same connection for both request and data – they are called In-Band protocols. 12. FTP is a stateful protocol – it remembers user information during the session. Transmission Modes In FTP  FTP can transfer files in three modes:  1. Stream Mode – Data is s", "latency_s": 45.9181}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "cn-notes", "pdf_name": "Computer-Network--_compressed.pdf", "pages": 42, "question_id": "cn_q15", "question": "Compare Go-Back-N and Selective Repeat protocols.", "expected": "- GBN retransmits all frames after error\n- SR retransmits only erroneous frame\n- SR requires more buffer memory", "method": "no_rag", "top_k": 0, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "Go-Back-N is a sliding window protocol where all unacknowledged frames are retransmitted when an error is detected. Selective Repeat allows for selective retransmission of only lost frames, potentially reducing overhead. Go-Back-N has simpler implementation but may have higher bandwidth usage due to retransmitting multiple frames.Selective Repeat is more complex but can be more efficient in certain scenarios.", "citations": "", "retrieved_chunks": "", "latency_s": 12.2398}
{"run_id": "20260107_210252_dca73668", "timestamp": "2026-01-07 21:02:54", "git_commit": "3495903453d127eaf1bf876d649aa8c30a2647b4", "pdf_id": "cn-notes", "pdf_name": "Computer-Network--_compressed.pdf", "pages": 42, "question_id": "cn_q15", "question": "Compare Go-Back-N and Selective Repeat protocols.", "expected": "- GBN retransmits all frames after error\n- SR retransmits only erroneous frame\n- SR requires more buffer memory", "method": "rag", "top_k": 5, "model_name": "qwen2.5:7b", "embed_model": "nomic-embed-text:latest", "chunk_size": "1200", "chunk_overlap": "200", "answer": "The provided context does not contain any information about the Go-Back-N or Selective Repeat protocols. Therefore, I cannot answer the question based on the given context.", "citations": "p39:c1|p28:c1|p40:c1|p26:c1|p40:c0", "retrieved_chunks": "p39: ● Handles fragmentation and reassembly of packets. Transport Layer  ● Provides end-to-end communication between applications on hosts. ● Ensures reliable or unreliable data delivery depending on protocol. ● Main protocols: ○ TCP (Transmission Control Protocol): reliable, connection-oriented, error- checked. COMPUETR NETWORK GATE फर्रे  Page No:- 35 | p28: ○ They use separate connections. 10. Some protocols (like FTP) send requests and data on different connections, so they are called Out-of-Band. 11. Others (like HTTP & SMTP) use the same connection for both request and data – they are called In-Band protocols. 12. FTP is a stateful protocol – it remembers user information during the session. Transmission Modes In FTP  FTP can transfer files in three modes:  1. Stream Mode – Data is s", "latency_s": 45.6864}
